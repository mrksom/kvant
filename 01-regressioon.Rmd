

# Lineaarne regressioon

```{r setup, include=FALSE}

knitr::opts_chunk$set(warning = F, message = F)

library(dplyr)
library(ggplot2)
library(wesanderson)
library(gridExtra)
library(tidyr)
library(stargazer)
cols <- wes_palette(5, name="Cavalcanti1", type = "discrete")[c(5,2,3,4,1)]

```

## Lihtne lineaarne regressioon

Lihtne lineaarne regressioon (*simple linear regression*) on statistiline meetod mis võimaldab hinnata ja kvantifitseerida kahe arvtunnuse vahelist suhet. Regressioonsuhte puhul eeldatakse, et üks tunnustest oleks nn sõltuv tunnus ja teine sõltumatu^[Inglisekeelses terminoloogias kasutatakse sõltuva tunnuse puhul peale *dependent variable* ka nimetusi *response* või *outcome variable* ja sõltumatu tunnuse puhul peale *independent variable* ka *predictor* või *explanatory variable*. Prediktor on ka eesti keeles kasutusel.], kus sõltuva tunnuse väärtus on mõjutatud (sõltub) sõltumatu tunnuse väärtusest. Kui sõltumatuid tunnuseid on rohkem kui üks, on tegemist mitmese regressiooniga (sellest hiljem), ühe sõltumatu tunnuse korral nn "lihtsa" regressiooniga (*simple linear regression*). Keskendume esialgu "lihtsale" variandile.

Kasutame näitena Piaaci andmestikku. Tõmbame andmestiku sisse ja uurime graafiliselt sissetuleku (*sissetulek*) ning matemaatilise kirjaokuse (*numeracy*) vahelist seost.

```{r reg-plot-1,  echo=T, warning=F, message=FALSE}

# Loeme kõigepealt sisse vajalikud paketid
library(dplyr)
library(ggplot2)
library(readr)

# Tõmbame  sisse andmestiku
piaac <- read_csv("https://github.com/mrksom/kvant/raw/master/data/piaac.csv")

piaac %>% 
  ggplot(aes(x = numeracy, y = sissetulek))+
  geom_point(size = 0.5, alpha = 0.3)+
  theme_minimal()
```


Tundub, et nende kahe tunnuse vahel on seos olemas. Mida kõrgem on matemaatilise kirjaoskuse skoor, seda kõrgem on sissetulek. Me saame selle suhte kokku võtta regressioonisirge abil. ggplotis on olemas vastav funktsioon `geom_smooth()`, mis selle joone meile graafikule paneb. Kuna me tahame saada lineaarse regressiooni sirget, siis peame `geom_smooth`'is kasutama argumenti `method = "lm"`^[*Defaultis* annab `geom_smooth` meile mittelineaarse regressioonijoone (vastavalt sellele palju vaatlusi on, kas *gam* või *loess*), mis üritab tunnustevahelist suhet andmete kõikides punktides võimalikult täpselt kirjeldada.]

```{r reg-plot-2,  echo=T, warning=F, message=FALSE}
piaac %>% 
  ggplot(aes(x = numeracy, y = sissetulek))+
  geom_point(size = 0.3, alpha = 0.2)+
  geom_smooth(method = "lm", se = F, color = "#972D15")+
  theme_minimal()
```

Regressioonisirge on väljendatav tavalise joone võrrandiga:

\begin{equation}
Y=a+bX
\end{equation}

kus $a$ on vabaliige (*intercept*) ja $b$ on sirge tõus (*slope*). Regressiooni kontekstis kutsutakse seda sirge tõusu regressioonikoefitsiendiks või regressioonikordajaks. Vabaliige tähistab $Y$ väärtust juhul kui $X$ on $0$ (sirge lõikumine y-teljega) ja sirge tõus ühikulist muutust $Y$ väärtuses kui $X$ väärtus muutub ühe ühiku võrra. Eelneva näite puhul oleks vabaliige võrdne sissetulekuga ($Y$) juhul kui matemaatilise kirjaoskuse tase ($X$) oleks $0$ ja sirge tõus võrdne keskmise sissetuleku muutusega, mis lisandub iga matemaatilise kirjaoskuse punktiga.  Kui sirge tõus on positiivne, siis $X$'i väärtuse kasvades $Y$ väärtus suureneb, kui negatiivne, siis kahaneb. Kui sirge tõus on aga $0$, siis seos kahe tunnuse vahel puudub (iga $X$ väärtuse korral on keskmine $Y$ sama).

Linaarse regressioonanalüüsi eesmärgiks ongi leida parim võimalik sirge (st leida vabaliige ja regressioonikoefitsient, mis seda sirget määratlevad) tunnustevahelise lineaarse suhte kirjeldamiseks. Parim võimalik tähendab siinjuures seda, et see sirge läheb punktiparvest läbi võimalikult keskelt, st kirjeldab kõiki punkte võimalikult hästi. 

## Regressioon R-is

R-is käib lihtsa regressioonimudeli tegemine `lm()` (*linear model*) funktsiooniga. Loomulikult on ka teisi funktsioone, mis regressiooni jooksutamisega hakkama saavad ja hea tahtmise korral võib vastava funktsiooni ka mõningase vaevaga ise valmis kirjutada. Kuid jätame teised variandid hetkel kõrvale.  

`lm()` funktsioonis tuleb defineerida regressioonivõrrand. Selleks  peame määratlema sõltuva tunnuse, seejärel kasutama tildet (`~`) ning seejärel määratlema sõltumatu(d) tunnuse(d): `sõltuv_tunnus ~ sõltumatu_tunnus`^[Hiljem, kui meil on mitu sõltumatut tunnust, eristame tunnused plussiga: `sõltuv_tunnus ~ sõltumatu_tunnus_1 + sõltumatu_tunnus_2 + ...`]. Võtame eelpool toodud näite sissetuleku ja matemaatilise kirjaoskuse seosest ning defineerime regressioonimudeli, millega hindame matemaatilise kirjaoskuse mõju sissetulekule^[Tegelikult ei ole selline mudel korrektne. Sissetuleku jaotus ei vasta hästi regressiooni nõuetele. Miks ei vasta ja kuidas see vastama panna, sellest natuke hiljem. Kuid hetkel kasutame seda puhtalt didaktilistest kaalutustest lähtuvalt.]:

```{r}
lm(sissetulek ~ numeracy, data = piaac)
```

Lihtsalt `lm()` funktsiooni jookustades saame kaks numbrit - vabaliikme (*intercept*), mis antud näite puhul on $-140$, ja regressioonikoefitsiendi (*regression coefficient*), mis antud näite puhul on $3.6$. Mida need meile ütlevad? Nagu eelnevalt juttu oli, siis vabaliige on $Y$ väärtus kui $X$ on $0$, ehk siis inimesel, kelle matemaatilise kirjaoskuse skoor on $0$, peaks meie mudeli kohaselt sissetulek olema $-140$. Regressioonikoefitsient aga annab meile teada kui palju $Y$ muutub, kui $X$ muutub ühe ühiku võrra, ehk siis kui matemaatilise kirjaoskuse skoor tõuseb ühe punkti võrra, tõuseb sissetulek keskmiselt $3.6$ euro võrra.
Nüüd, kui teame mudeli parameetreid, saame nende abil regressioonijoone graafikule kanda ka ilma `geom_smooth`'ita:

```{r reg-plot-3,  echo=T, warning=F, message=FALSE}
piaac %>% 
  ggplot(aes(x = numeracy, y = sissetulek))+
  geom_point(size = 0.3, alpha = 0.2)+
  geom_abline(slope = 3.6, intercept = -140, color = "#972D15")+
  coord_cartesian(xlim = c(0,450), ylim = c(0,3500))+
  theme_minimal()

```


Kui me teame regressioonisirge tõusu ehk regressioonikoefitsienti ja vabaliiget, siis lähtuvalt sõltumatu tunnuse väärtustest saame prognoosida sõltuva tunnuse väärtuse: 

\begin{equation}
  \hat{y}_i=b_0+b_1x_i
\end{equation}

$\hat{y}_i$ antud võrrandis tähistab hinnatud või prognoositud $y$ väärtust (sellest ka see müts $y$ peal) vaatlusele $i$. Kui meil on regressioonivõrrand $\hat{y}_i=-140+3.6x_i$ ja meil on mingi vaatlus $i$, kelle $x$ väärtus on näiteks $200$, siis saame sellele vaatlusele prognoosida $y$ väärtuseks $-140+3.6\times200=580$. Ehk siis inimesel, kelle matemaatilise kirjaoskuse skoor on 200, peaks meie mudeli järgi sissetulek olema *ca* 580 eurot. Inimesel, kelle matemaatilise kirjaoskuse skoor on 400, peaks sissetulek olema keskmiselt $-140+3.6\times400=1300$ eurot

```{r reg-plot-4, fig.cap = "Prognoosime y väärtust kui x on 200 ja kui x = 400",  echo=F, warning=F}

ggplot(data=data.frame(x=c(200, 400), y=c(580, 1300)), aes(x=x, y=y)) + 
  geom_point()+
  geom_abline(intercept = -140, 
              slope = 3.6)+
  scale_y_continuous(limits=c(100,2000))+
  scale_x_continuous(limits=c(100,400))+
  geom_segment(x=0, xend=200, y=580, yend=580, linetype=2, colour=cols[1])+
  geom_segment(x=200, xend=200, y=0, yend=580, linetype=2, colour=cols[1])+
  geom_segment(x=0, xend=400, y=1300, yend=1300, linetype=2, colour=cols[1])+
  geom_segment(x=400, xend=400, y=0, yend=1300, linetype=2, colour=cols[1])+
  theme_bw()+
  labs(x = "Matemaatiline kirjaoskus", y = "Sissetulek")

```

## Regressiooni jäägid
Samas on muidugi võimatu ühe sirgega kõiki punkte ideaalselt kirjeldada. Iga punkti ja sirge vahele jääb alati mingi viga või teisisõnu, kõik punktid (või vähemalt enamus neist) hälbivad suuremal või vähemal määral regressioonisirgest.  

Mida suuremad need hälbed on, seda vähem suudab on meie mudel (regressioonisirge) kirjeldada sõltuva tunnuse variatsiooni ja seda suurem on vea määr meie mudelis. Neid hälbeid kutusutakse **regressiooni jääkideks** (*regression residuals*). 

```{r reg-plot-5, fig.cap = "Regressiooni jäägid",  echo=F, warning=F}
# coefs
b0 <- 38.93
b1 <- 0.85
sigma <- 27
set.seed(23)
x = runif(15, 60, 350)
eps = rnorm(15,0,sigma)
y = b0 + b1*x + eps

# gen data

dt <- data.frame(x, eps, y)
dt$fitted <- lm(y~x, dt)$fitted

# plot
ggplot(dt, aes(x = x, y = y)) + 
  geom_abline(intercept = lm(y~x, dt)$coefficients[[1]], 
              slope = lm(y~x, dt)$coefficients[[2]])+
  geom_segment(aes(x=x, xend=x, y=y, yend=fitted), color=cols[1], size = 0.5)+
  geom_point(size=2)+
  theme_minimal()+
  labs(x = "Matemaatiline kirjaoskus", y = "Sissetulek")

```

Ehk siis iga kord, kui prognoosime $\hat{y}_i=\beta_0+\beta_1x_i$ abil $y_i$ väärtust, teeme me mingi vea^[Mida saab väljendada kui $\epsilon_i=y_i-\hat{y}_i$]. Seetõttu tuleb regressioonivõrrandile lisada vea komponent ($\epsilon$) ning võrrand ise muutub vastavalt:

\begin{equation}
  \hat{y_i}=\beta_0+\beta x_i+\epsilon
\end{equation}

Kõige parem regressioonisirge annab joon, mille puhul jäägid on minimaalsed, ehk siis joon, mille puhul kõikide vaatluste jääkide summa oleks võimalikult väike. Kuna me ei saa jääke kokku võtta neid lihtsalt kokku liites (*ca* pooled jäägid on väiksemad kui regressioonijoon ja *ca* pooled suuremad, seega nende summa oleks $0$), siis tuleb nad enne liitmist ruutu panna. Ja meie eesmärgiks on nüüd leida regressioonisirge, mis minimeeriks **ruutjääkide summa** (*residual sum of squares* ehk $RSS$) ehk siis regressioonisirge, mille puhul $RSS$ oleks võimalikult väike^[$RSS= = e_1^2 + e_2^2 + ... + e_n = \sum_{i=1}^{n}(y_i-\hat{y}_i)^2$].

Eelnevast lähtuvalt on ka küllaltki loogiline, et meetodit, millega $RSS$ minimeeritakse ja regressioonisirge ning vastavad koefitsiendid leitakse, nimetatakse **vähimruutude meetodiks**. 



::: {.teie-kord}
Ülesanne!  

* Kasutades ggplot'i ja tehke punktdiagramm `geom_point()` matemaatilise kirjaoskuse (*numeracy*) ja funktsionaalse lugemisoskuse (*literacy*) vahelisest seosest. Pange *numeracy* x-teljele ja *literacy* y-teljele.  
* Kasutades `geom_abline()`'i, lisage joonisele lineaarne regressioonijoon (seega peate eelnevalt `lm()` funktsiooniga leidma regressioonijoone vabaliikme ja regressioonikoefitsiendi)
:::



## Regressioonimudeli sobitumine

Olles leidnud joone, mis kirjeldab kahe tunnuse vahelist seost kõige paremini, võiks ju eeldada, et ülesanne on täidetud. Aga kas ikka on? Ükskõik, millisest punktiparvest võib regressioonijoone läbi panna. Kuid tulenevalt regressioonijääkide (vaatluste hälbed regressioonijoonest) suurusest saame selle joone kohta teha väga erinevaid järeldusi. Kui jäägid on väikesed, siis võime suhteliselt täpselt prognoosida sõltuva tunnuse väärtust või teha järeldusi seose kohta. Kuid mida suuremad on jäägid, seda ebatäpsem on ka meie prognoos/järeldus. 

Üldjuhul kasutame regresioonanalüüsi, et teha valimi baasil järeldusi mingi üldkogumi kohta. Meid huvitab, kas see seos, mida näeme oma valimi andmete põhjal, kehtib ka üldkogumis. Saame küll eeldada, et valimipõhiselt leitud regressioonisirge on suhteliselt sarnane üldkogumi sirgele (sirge, mille me saaksime, kui kaasaksime analüüsi kõik üldkogumi liikmed), aga kui sarnane, seda me ei tea. Kui me võtaksime samast üldkogumist teise valimi, siis juhul, kui mõlemad valimid on võetud korrektselt^[Korrektse valimi võtmise all peame siinkohal silmas eelkõige juhuvalikut. Kõikidel populatsiooni liikmetel/elementidel peab olema võrdne võimalus valimisse sattuda. Kui üldpopulatsiooniks on Eesti elanikkond, aga valimisse võtaksime ainult Tallinna elanikud, siis antud valimi põhjal tehtavad järeldused ei oleks kuidagi üldistatavad kõigile Eesti elanikele, vaid ikkagi ainult tallinnlastele. Lisaks juhuvalimile on veel terve rida spetsiifilisemaid valimidisaine (stratifitseeritud valim, klastervalim jne) mida me hetkel ei käsitle. Kuid tuleb meeles pidada, et keerulisemate valimidisainide puhul tuleb hilisemas analüüsis ja järelduste tegemise käigus valimi moodustamise loogikat arvesse võtta.] ja valimid on piisavalt suured, siis peaksid nende põhjal leitud regressioonisirged olema suhteliselt sarnased, aga identsed ei ole nad praktiliselt kunagi. Kõikide võimalike valimite puhul me mingil määral alahindame või ülehindame tegelikku, populatsiooni regressioonikoefitsienti (ja ka vabaliiget). Seega, et saada aimu valimipõhise hinnangu täpsusest (vastavusest tegelikule tegelikule üldkogumi parameetrile), peaksime kuidagi välja selgitama valimi kasutamisest tuleneva vea võimaliku suuruse.

Et hinnata mudeli sobivust andmetega ja sellega leitud hinnagute täpsust, vajame mudeli kohta täiendavat infot. Eelnevalt regressioonimudelit `lm()` funktsiooniga jooksutades oli väljund väga lakooniline. Saime teada ainult vabaliikme ja regressioonikoefitsinedi väärtused. Tegelikult on `lm()` tulem muidugi märksa põhjalikum. Muule mudeliga kaasnevale infole saame ligi kui salvestame mudeli esmalt mingisse andmeobjekti ja kasutame selle andmeobjekti peal `summary()` käsku^[Ka `summary()` ei anna välja kogu mudeliobjektis sisalduvat infot. Et näha mida mudeliobjekt veel sisaldab, võib kasutada `str(mudeliobjekt)` käsku.]. 

```{r}
mudel1 <- lm(sissetulek ~ numeracy, data = piaac)
summary(mudel1)
```

```{r, eval = F}
# Kui me ei taha mudelit salvestada, siis saab ka nii:
summary(lm(numeracy ~ literacy, data = piaac))
```


Nüüd näeme juba märksa põhjalikumat väljundit. Vaatame mis seal kirjas on ja kuidas seda tõlgendada. Käime väljundi sektsioonide kaupa läbi (v.a. esimene rida, mis on vist niigi suht selge)

### Jääkide jaotus

```{r echo=FALSE}
out <- capture.output(summary(mudel1))
cat(out[5:7], sep = "\n")
```

Väljundis on kirjeldatud regressiooni jääkide (*residuals*) jaotus. Enne nägime, et regressiooni jäägid on regressioonijoone ja tegelike, vaadeldud väärtuste vahe. Mida väiksemad on jäägid, seda täpsemini kirjeldab regressioonijoon andmete vahelist seost. Nägime ka, et pooled jäägid peaksid ideaalis olema suuremad (positiivse märgiga) kui regressioonisirge ja pooled väiksemad (negatiivse märgiga). Seega peaks jääkide keskmine olema ligikaudu $0$ ning jääkide jaotus normaaljaotuse sarnane, kus esimene ja kolmas kvartiil, aga ka maksimum ja miinimum, on keskväärtusest umbes sama kaugel. Hiljem vaatame jääkide jaotust ka graafiliselt, mis on märksa mõistlikum viis neid uurida, kuid esmase mulje saab ka siit kätte.

### Regressioonikoefitsiendid ja nende olulisus

```{r echo=FALSE}
out <- capture.output(summary(mudel1))
cat(out[10:14], sep = "\n")
```

Koefitsientide sektsioonis on esitatud mudeli oluliseim info. __*Estimate*__ on hinnang mudeliga leitud regressioonikoefitsientidele. Lihtsa regressiooni puhul on meil ainult vabaliige ja ühe sõltumatu tunnuse koefitsient. Hiljem, mitmese regressiooni kontekstis, on neid koefitsiente rohkem. Vabaliikmeid on aga mudeli kohta alati üks.  

Tulbas __*Std. Error*__ on toodud koefitsientide standardvead. Standardviga kirjeldab meie mudeli hinnangus sisalduvat määramatust. Me kasutame regressioonikoefitsientide leidmiseks üldjuhul valimipõhiseid andmeid, kuigi tegelikult huvitavad meid ju üldkogums esinevad seosed. Valimipõhine hinnang peaks piisavalt suure valimi korral olema tõenäoliselt küllaltki sarnane üldkogumi vastavale parameetrile, kuid väikese valimi korral puhta juhuse läbi sellest arvestatavalt erineda. Standardviga näitabki kui kindlad me oma mudeli hinnangus olla saame. Mida väiksem on standardviga (võrreldes hinnangu endaga), seda kindlamad võime olla ka oma hinnangus. Standardvea suurs sõltub eelkõige jääkide hajuvusest ja valimi suurusest. Mida väiksemad on jäägid ja mida suurem on valim, seda väiksem on ka standardviga.  

Standardvea abil saame *t*-testi abil testida, kas regressioonikoefitsient erineb oluliselt nullist (kui koefitsient on null, siis seos tunnuste vahel puudub). *t*-testi tulemust näitab veerg __*t value*__. *t*-väärtus ütleb meile kui mitme standardvea kaugusel meie regressioonikoefitsient 0-st on. Kui on piisavalt kaugel, siis saame järeldada, et leitud koefitsient on ka üldkogumis 0-st erinev. Kui kaugel on aga piisavalt kaugel? See sõltub sellest, kui suurt vea tõenäosust me oleme valmis tolereerima (mingi vea tõenäosus jääb seejuures alati). Üldjuhul valitakse selleks tõenäosuseks $5\%$ (ütleme, et regressioonikoefitsient on statistiliselt oluline usaldusnivool $95 \%$ või olulisusnivool $p < 0.05$), aga see võib olla ka $1\%$ või $10\%$. Siin tegelikult ei ole mingit väga konkreetset piirmäära, millest juhinduda. Kui me aga lepime kokku, et võimaliku vea tõenäosusena aktsepteerime $5$-te protsenti, siis peab *t*-väärtus olema suurem kui *ca* $\pm2$ (täpne väärtus sõltub vaatluste arvust). Antud näite puhul on *t*-väärtused $-2.5$ ja $17.8$, ehk siis mõnevõrra suuremad kui $\pm2$ ja me võime järeldada, et nii vabaliige kui regressioonikoefitsient erinevad olulisusnivool $95\%$ oluliselt nullist (kuigi jah, vabaliige on suhteliselt piiri peal).  

Õnneks ei pea me seda täpset *t*-väärtuse piirmäära ise välja nuputama. R arvutab meile automaatselt võimaliku vea tõenäosuse konkreetse *t*-väärtuse kohta. See tõenäosus on ära toodud veerus __*Pr(>|t|)*__ ja seda nimetatakse *p*-väärtuseks. *p*-väärtuse tõlgendus on: kui tõenäoline on, et me saaksime niivõrd suure või suurema *t*-väärtuse nagu me saime, kui regressioonikoefitsient oleks üldkogumis tegelikult $0$. Seega kui *p*-väärtus on näiteks $0.04$, siis oleks tõenäosus, et me saaksime sellise regressioonikoefitsiendi, juhul kui üldkogumis oleks regressioonikoefitsient tegelikult $0$ (ehk tunnuste vahe seost ei oleks), $0.04$ ehk $4$% või väiksem. Üldjuhul tahaksime näha *p*-väärtust, mis on väiksem kui $0.05$. Sellisel juhul oleks koefitsient statistiliselt oluline usaldusnivool $95\%$. Antud näites on meil regressioonikoefitsiendi puhul tegemist väga väikeste *p* väärtustega (<2e-16 tähendab väiksem kui $2\times10^{-16}$) ja me võime olla päris kindlad, et koefitsient erineb nullist. Vabaliikme *p*-väärtus on aga $0.012$, ehk kui me kasutaksime usaldusnivood $99\%$ (mille puhul *p*-väärtus peaks olema väiksem kui $0.01$), siis me ei saaks järeldada, et see on statistiliselt oluliselt erinev nullist. Lisaks kuvab R iga *p*-väärtuse taha ka tärnid, mis indikeerivad selle väärtuse suurust lähtuvalt allolevast legendist.  

Miks meil on üldse vaja teada kas koefitsiendid erinevad oluliselt nullist? Aga sellepärast, et kui regressioonisirge oleks $0$, siis meie tunnuste vahel ei oleks seost (kui $X$ muutub $1$ ühiku võrra, siis $Y$ muutub $0$ ühiku võrra, ehk siis $Y$ väärtus ei sõltu $X$'i väärtusest). Aga kuidas on lood vabaliikmega? Kas ka see peab erinema nullist, et meie mudelist mingit tolku oleks? Tegelikult ju ei pea. Võib täitsa vabalt juhtuda, et regressioonisirge lähebki läbi $X$ ja $Y$ telgede ristumiskoha ($Y$ on $0$ kui $X$ on $0$). Sellisel juhul oleks vabaliikme *t*-väärtus väiksem kui $2$ ja *p*-väärtus suurem kui 0.05, kuid mudeli tõlgendust see ei mõjutaks. Ehk siis tavaliselt meid vabaliikme *p* ja *t* väärtused väga ei huvita. Küll aga peaks jälgima, et standardviga väga suur (võrreldes vabaliikme endaga) ei oleks.

### Jääkide standardviga

```{r echo=FALSE}
out <- capture.output(summary(mudel1))
cat(out[16:17], sep = "\n")
```

Kuidas hinnata regressiooniprognoosi täpsust, ehk siis seda kui hästi regressioonimudel sobitub andmetega (*model fit*)? Üheks võimaluseks on lähtuda samast loogikast mida kasutame tunnuse keskväärtuse täpsuse hindamisel. Ehk kui palju vaatlused keskmiselt erinevad keskväärtusest. Regressioonijoone puhul ei ole meil ühte keskväärtust, mille suhtes vaatluste hälbimist määrata. Kuid iga vaatluse sõltumatu tunnuse väärtuse $x$ kohta on meil "hinnatud" sõltuva tunnuse väärtus $\hat{y}$. Seega tuleb meil lihtsalt vaadata kui palju vaatluste $y$ ja $\hat{y}$ väärtused keskmiselt erinevad, ehk kui suur on keskmine viga meie mudelis. Regressioonanalüüsi kontekstis kutsutakse seda vaatluste varieeruvuse näitajat keskmiseks ruutveaks (*mean squared error*) ehk lühidalt $MSE$:

 
\begin{equation}
  $MSE=\frac{\sum_{i=1}^{n}(y_i-\hat{y}_i)^2}{n-k}$
\end{equation}

kus $n$ on vaatluste arv ja $k$ on regressioonikoefitsientide arv (kaasa arvatud vabaliige).

Kuna aga $MSE$ väärtus on ruudus, siis on seda keeruline interpreteerida (samamoodi nagu ka dispersiooni). Kui me võtame ruutjuure $MSE$'st, $\sqrt{MSE}$, saame regressiooni jääkide standardhälbe, mida nimetatakse **jääkide standardveaks** (*residual standard error* ehk RSE). Mida väiksem on mudeli RSE, seda paremini mudel andmetega sobitub (seda vähem hälbivad vaatlused regressioonijoonest ehk seda väiksemad on regresiooni jäägid). See, kui väike peaks RSE väärtus hea mudeli korral olema, sõltub eelkõige kontekstist ja sõltuva tunnuse skaalast (samamoodi nagu keskväärtuse standardhälve). Mingeid konkreetseid piirväärtusi siinkohal tuua ei ole võimalik.  
Lisaks on siin ära toodud ka *degrees of freedom* ehk vabadusastmete arv jääkide standardvea arvutamisel. Sisuliselt on siin kirjas analüüsi kaasatud vaatluste arv (miinus regressioonikordajate arv, siinses mudelis 2). Ära on toodud ka analüüsist välja jäetud vaatluste arv. Need on need, kellel puudus väärtus vähemalt ühe analüüsitava tunnuse jaoks.

### R ruut

```{r echo=FALSE}
out <- capture.output(summary(mudel1))
cat(out[18], sep = "\n")
```

Vast oluliseimaks mudeli headuse näitajaks on $R^2$. Regressioonanalüüsi eesmärk on seletada mingit osa sõltuva tunnuse variatiivsusest sõltumatu tunnuse abil. Seega saame regressioonimudeli puhul hinnata ja mudeli kvaliteedi iseloomustusena kasutada sõltumatu tunnuse poolt seletatud variatiivsuse osakaalu sõltuva tunnuse koguvariatiivsusest. Sõltuva tunnuse variatiivsuse (seda nimetatakse $TSS$ ehk *total sums of squares*) saab jagada komponentideks: variatiivsus, mis on seletatud regressioonijoone poolt ($ESS$ ehk *explained sums of squares*) ja variatiivsus, mis ei ole regressioonijoone poolt seletatud ehk siis mudeli seisukohast viga ($RSS$ ehk *residual sums of squares*): 

$$TSS=RSS+ESS$$


\begin{equation}
  ESS=\sum_{i=1}^{n}(\hat{y}_i-\bar{y})^2
\end{equation}

\begin{equation}
  RSS=\sum_{i=1}^{n}(y_i-\hat{y}_i)^2
\end{equation}

\begin{equation}
  TSS=\sum_{i=1}^{n}(y_i-\bar{y})^2
\end{equation}


Teades erinevaid variatiivsuse komponente, saame määrata kui suur osa (mitu protsenti) sõltuva tunnuse koguvariatsioonist on seletatav regressioonijoone poolt (ehk siis sõltumatu tunnuse poolt). Seda suurust nimetatakse **determinatsioonikordajaks** ehk lühidalt $R^2$-ks. 

\begin{equation}
  R^2=\frac{TSS-RSS}{TSS}=1-\frac{RSS}{TSS}
\end{equation}

```{r ss, fig.cap = "Variatsiivsuse jagunemine",  echo=F, warning=F}
# coefs
b0 <- 30
b1 <- 7
sigma <- 9
set.seed(23)
x = runif(15, 60, 480)/60
eps = rnorm(15,0,sigma)
y = b0 + b1*x + eps

# gen data

dt <- data.frame(x, eps, y)
dt$fitted <- lm(y~x, dt)$fitted
dt$mean_y=mean(dt$y)

# plot1
pl1 <-ggplot(dt, aes(x = x, y = y)) + 
  geom_point(size=1)+
  geom_hline(aes(yintercept = mean_y))+
  geom_segment(aes(x=x, xend=x, y=y, yend=mean_y), color=cols[1])+
  theme_bw()+
  ggtitle("TSS")


pl2 <- ggplot(dt, aes(x = x, y = y)) + 
  geom_point(size=1)+
  geom_abline(intercept = lm(y~x, dt)$coefficients[[1]], 
              slope = lm(y~x, dt)$coefficients[[2]])+
  geom_segment(aes(x=x, xend=x, y=y, yend=fitted), color=cols[1])+
  theme_bw()+
  ggtitle("RSS")

pl3 <- ggplot(dt, aes(x = x, y = y)) + 
  geom_point(size=1, alpha=0.3)+
  geom_hline(aes(yintercept = mean_y))+
  geom_abline(intercept = lm(y~x, dt)$coefficients[[1]], 
              slope = lm(y~x, dt)$coefficients[[2]])+
  geom_segment(aes(x=x, xend=x, y=mean_y, yend=fitted), color=cols[1])+
  theme_bw()+
  ggtitle("ESS")

grid.arrange(pl1, pl2, ncol=2)

```


$R^2$ jääb vahemikku $0-1$. See mõõdab seose tugevust, st mida lähemal $R^2$ on $1$'le, seda tugevam lineaarne seos tunnuste vahel on ja seda enam sõltumatu tunnus sõltuva tunnuse variatsiooni seletab, seega seda efektiivsem on regressioonifunktsiooni kasutamine selle asemel, et lihtsalt sõltuva tunnuse keskmist hinnata (kui $R^2$ on $0$, siis regressioonijoon langeb kokku sõltuva tunnuse keskmist tähistava joonega, st et $ESS=0$ ja $TSS=RSS$).  

R annab meile lisaks tavalisele $R^2$ väärtusele (*Multiple R-squared*) ka nn korrigeeritud $R^2$ väärtuse (*Adjusted R-squared*). Korrigeeritud $R^2$ puhul võetakse arvesse ka sõltumatute tunnuste arvu. Iga lisanduva sõltumatu tunnusega läheb "tavaline" $R^2$ suuremaks. Kui lisanduv tunnus eriti midagi ei seleta, siis võib see tõus olla väga väike, kuid mingi tõus paratamatult on. Korrigeeritud $R^2$, arvestades oma valemis ka sõltumatute tunnuste arvu, annab mitme sõltumatu tunnuse korral korrektsema tulemuse. Hetkel, lihtsa regressiooni kontekstis, kus meil on ainult üks sõltumatu tunnus, annavad mõlemad variandid (enam-vähem) sama tulemuse. 

### F-väärtus ja F-test

```{r echo=FALSE}
out <- capture.output(summary(mudel1))
cat(out[19], sep = "\n")
```

*F*-väärtus, sarnaselt *t*-väärtusele, aitab meil hinnata kas meie mudel on statistiliselt oluline, ehk siis kas meie analüüsitavate tunnuste vahel on oluline lineaarne seos. *F*-väärtuseks nimetatakse mudeli abil seletatud variatiivsuse ja seletamata variatiivsuse suhet:

\begin{equation}
\text{F-suhe} = \frac{\text{regressioonimudeli poolt seletatud variatiivsus}}{\text{regressioonimudeli poolt seletamata variatiivus}}
\end{equation}


Natuke täpsemalt väljendades: 

$$F = \frac{(TSS-RSS)/(k-1)}{RSS/(n-k)}$$ 

kus $n$ on valimi suurus ja $k$ on regressioonikoefitsientide (sõltumatute muutujate) arv.

Kui mudeli regressioonisirge on $0$, siis peaks see suhe olema $1$. See tähendab, et regressioonisirge ei seleta üldse sõltuva tunnuse varieeruvust. Kui regressioonisirge on suurem kui $0$ siis peaks regressioonisirge poolt seletatud varieeruvus (koos juhusliku varieeruvusega) olema suurem kui ainult juhuslik dispersioon. Saame jällegi kasutada *F*-väärtusega kaasnevat *p* väärtust, et hinnata kas see *F*-väärtus on piisavalt suur, et saaksime mudelist lähtuvalt mingeid sisukaid järeldusi teha.  

Võite märgata, et t-test ja F-test annavad meie mudeli puhul sama *p* väärtuse. Ja tegelikult annavad nad ka sama teststatistiku. *t*-statistik on lihtsalt ruutjuur *F*-statistikust^[$(t^{*}_{(n-2)})^2=F^{*}_{(1,n-2)}$]. Võib tekkida küsimus, et miks me siis kahte testi peame kasutama. Ühe sõltumatu tunnusega regressioonimudelis otseselt ei peagi. Samas kui meil on mitu sõltumatut tunnust (nagu meil hiljem on), siis *F* ja *t* väärtused muutuvad. *F*-testiga saab sel juhul testida terve mudeli headust, st kas meie sõltumatud tunnused koos suudavad seletada piisavalt sõltuva tunnuse variatiivsust (tegelikult testib *F*-test seda, et kas vähemalt üks koefitsientidest erineb nullist). *t*-statistikud aga arvutatakse igale regressioonikoefitsiendile eraldi ning nendega saame kontrollida iga üksiku koefitsiendi erinevust nullist.



::: {.teie-kord}
Ülesanne!  

* Looge regressioonimudel, millega hindate *numeracy* mõju *literacy*'le.  
* Salvestage see mudel ja uurige `summary()` funktsiooniga. 
* Kas *numeracy* mõju *literacy*'le on statistiliselt oluline?  
* Mitu protsenti *literacy* variatsioonist on selgitatav läbi *numeracy*?
:::



## Kategoriaalsed tunnused regressioonis

### Üks binaarne sõltumatu tunnus

Siiani oleme käsitlenud ainult mudeleid, kus sõltumatuteks tunnusteks on pidevad muutujad. Kuid me saame mudelisse lülitada ka kategoriaalseid tunnuseid. Vaatame esmalt mudelit, kus on üks kategoriaalne sõltumatu muutuja^[Sellist mudelit nimetatakse ka ANOVA-ks või täpsemlat One-Way ANOVA-ks (kuna tegemist on ainult ühe kategoriaalse sõltumatu muutujaga)]. Teeme Piaaci andmete põhjal mudeli, millega hindame soo mõju sissetulekule

```{r}
mudel2 <- lm(sissetulek ~ sugu, data = piaac)
summary(mudel2)
```

Kuidas seda tulemust tõlgendada?   

Regressioonimudeliga hindame $\hat{y_i}$ väärtust vaatlusele $i$, kui sõltumatu tunnuse väärtus muutub ühe ühiku võrra. $\hat{y_i}$'i väärtus kujuneb siis lähtuvalt vabaliikme $\beta_0$ ja  regressioonikoefitsiendi $\beta$ ning sõltumatu tunnuse $x_i$'i korrutise summast (pluss mingi viga): $\hat{y_i}=\beta_0+\beta x_i+\epsilon$. Sealjuures vabaliige on $y$ väärtus kui $x$ on $0$.   

Meil on tunnus  $x$ (sugu) kahe kategooriaga. Mis juhtub, kui kodeerime selle ümber väärtusteks $0$ ja $1$ (vastavalt mees ja  naine). R kusjuures teeb seda automaatselt. 

\[ x_{i} =
  \begin{cases}
    1  & \quad \text{kui on naine}\\
    0  & \quad \text{kui on mees}
  \end{cases}
\]  

Kui me selle tunnuse nüüd regressioonivõrrandisse paneme, siis mis on $y_i$ väärtus kui $x_i$ on $1$ (ehk siis vaatluse sugu on naine) ja mis on $y_i$ väärtus kui $x_i$ on $0$ (ehk siis vaatluse sugu on mees)? 

\[ \hat{y_i}=\beta_0+\beta_1 x_i =
  \begin{cases}
    \beta_0+(\beta_1 \times 1) = \beta_0+\beta_1  & \quad \text{kui on naine}\\
    \beta_0+(\beta_1 \times 0) = \beta_0  & \quad \text{kui on mees}
  \end{cases}
\]  

Ehk siis kui $x_i$ väärtus on $0$ (mehed), siis võrdub $\hat{y_i}$ vabaliikmega $\beta_0$ (sest $\beta_1$ korrutatakse läbi nulliga) ja kui $x_i$ väärtus on $1$ (naised), siis vabaliikme ja regressioonikoefitsiendi summaga $\beta_0+\beta$. Mida $\hat{y}$ antud juhul üldse tähistab? Pidevmuutujaga regressioonis tähistas see keskmist $y$-i väärtust erinevate $x$ väärtuste korral. Ja siin täpselt samamoodi. Aga nüüd on meil ainult kaks $x$ väärtust ja $\hat{y}$ on vastavate gruppide (meeste ja naiste) keskmine $y$.

Seega saame regressioonivõrrandiga väljenda binaarse tunnuse mõju sõltuva tunnuse keskmisele. Lihtsalt käsitleme ühte kategooriat nn **referentskategooriana** ja kodeerime selle $0$'ks. Kui $x$ on $0$, siis $y$ väärtus on võrdne vabaliikme väärtusega. Ja kui sõltumatu tunnuse väärtus muutub ühe ühiku võrra (ja rohkem ta ei saagi muutuda), siis on $y$ väärtus võrdne vabaliikme väärtus pluss regressioonikoefitsiendi väärtus. 

Kuidas me eelneva valguses oma näidet siis tõlgendama peaksime?

```{r echo=FALSE}
out <- capture.output(summary(mudel2))
cat(out[9:12], sep = "\n")
```

*Sugu* oli tekstiline tunnus. R saab aru, et tegemist on kategoriaalse tunnusega ja kodeerib selle sisemiselt ümber $0$-ks ja $1$-ks. Antud juhul määras ta kategooria *Naine* $1$-ks ja kategooria *Mees* $0$-ks. Kuna tegemist oli tekstilise tunnusega, siis lähtub R siin tähestikulisest järjekorrast. Ümberkodeeritud (dihhotomiseeritud) tunnuse nimeks on alati mitte-referentskategooria. Antud juhul siis *suguNaine*. Regressioonivõrrand oli järgmine:

\[\hat{y_i}=\beta_0+\beta x_i+\epsilon\]  

kus

\begin{align}
x_{i} =
  \begin{cases}
    1  & \quad \text{kui on naine}\\
    0  & \quad \text{kui on mees}
  \end{cases}
\end{align}

Paneme mudeli tulemused sellesse võrrandisse:

\begin{align}
\text{keskmine sissetulek}&=1077.90+(-383.15)\times \text{naine}\\
&=
  \begin{cases}
    1077.90-383.15\times 1 & \quad \text{kui on naine}\\
    1077.90-383.15\times 0 & \quad \text{kui on mees}
  \end{cases}\\
&=
  \begin{cases}
    1077.90-383.15 & \quad \text{kui on naine}\\
    1077.90-0 & \quad \text{kui on mees}
  \end{cases}\\
&=
  \begin{cases}
    694.75 & \quad \text{kui on naine}\\
    1077.90 & \quad \text{kui on mees}
  \end{cases}
\end{align}

Ehk siis naiste keskmine sissetulek on $694.8$ eurot (vabaliige + regressioonikoefitsient) ja meeste oma $1077.9$ eurot (vabaliige). Erinevus on statistiliselt oluline, kuna *p*-väärtused nii koefitsiendi *t*-testi kui ka mudeli *F*-testi puhul olid olulisusnivool $95\%$ olulised (väiksemad kui $0.05$).

Kui me paneme need keskmised joonisele ja ühendame nad joonega, näeme, et selle joone tõus (*slope*) on võrdne regressioonikoefitsiendiga, täpselt samuti nagu pidevtunnusega regressioonis.

```{r reg-plot-6, echo=F, warning=F}
piaac %>% 
  group_by(sugu) %>% 
  summarise(`Keskmine sissetulek` = mean(sissetulek, na.rm = T)) %>% 
  ggplot(aes(x = sugu, y = `Keskmine sissetulek`, group = 1))+
  geom_point()+
  geom_line()+
  theme_minimal()
```

### Kolme või enama kategooriaga sõltumatu tunnus

Kusjuures me ei pea piirduma vaid binaarsete tunnustega. Aga kui kategooriaid on rohkem, tuleb meil nad binaarseks teha ehk dihhotomiseerida. Määratleme ühe kategooria referentskategooriana ja ülejäänud kategooriad kodeerime erinevates tunnustes $1$'ks. Seega, kui meil on näiteks hariduse tunnus kolme kategooriaga (põhiharidus, keskharidus, kõrgharidus), peame määratlema ühe referentskategooria (näiteks põhiharidus) ja tegema kaks uut tunnust (vastavalt keskhariduse ja kõrghariduse kategooriatele):


\[ kesk_{i} =
  \begin{cases}
    1  & \quad \text{kui inimene on keskharidusega}\\
    0  & \quad \text{kui inimene ei ole keskharidusega}
  \end{cases}
\]  

\[ korg_{i} =
  \begin{cases}
    1  & \quad \text{kui inimene on kõrgharidusega}\\
    0  & \quad \text{kui inimene ei ole kõrgaridusega}
  \end{cases}
\]

Nüüd saame iga inimese hariduse määratleda kahe tunnuse kaudu. Ehk siis inimene, kelle puhul $kesk = 1$ ja $korg = 0$, on keskharidusega; inimene kelle puhul $kesk = 0$ ja $korg = 1$, on kõrgharidusega ja inimene kelle puhul $keks = 0$ ja $korg = 0$, on põhiharidusega. $y$ väärtus kujuneb täpselt samamoodi nagu binaarse tunnuse puhul:


$$y_i=\beta_0+\beta_1 \times kesk_i+\beta_2 \times korg_i$$


\begin{align}
&=
  \begin{cases}
    \beta_0+\beta_1 \times 1+\beta_2 \times 0  & \quad \text{keskharidusega}\\
    \beta_0+\beta_1 \times 0+\beta_2 \times 1  & \quad \text{kõrgaridusega}\\
    \beta_0+\beta_1 \times 0+\beta_2 \times 0  & \quad \text{põhiharidusega}
  \end{cases}\\
&=
  \begin{cases}
    \beta_0+\beta_1  & \quad \text{keskharidusega}\\
    \beta_0+\beta_2  & \quad \text{kõrgaridusega}\\
    \beta_0  & \quad \text{põhiharidusega}
  \end{cases}
\end{align}


Vaatame kuidas see kõik R-is välja näeb. Hindame hariduse (tunnus *haridustase*) mõju sissetulekule:

```{r}
mudel3 <- lm(sissetulek ~ haridustase, data = piaac)
summary(mudel3)
```

R sai jällegi ise aru, et *haridustase* on tekstiline tunnus ja dihotomiseeris selle automaatselt ära, tehes kaks uut tunnust: *haridustaseKõrge* (kus kõik kõrgharitud on kodeeritud $1$-na ja kõik teised $0$-na) ja *haridustaseMadal* (kus kõik madala haridustasemega on kodeeritud $1$-na ja kõik teised $0$-na). Referentskategooriaks võttis ta tähestiku järjekorras esimese kategooria *Keskmine* (kõik vaatlused, mille puhul nii *haridustaseKõrge* kui ka *haridustaseMadal* on $0$-d, on keskmise haridustasemega).  

Tulemuste interpreteerimine toimub samamoodi nagu binaarse tunnuse puhul. Vabaliige tähistab referentskategooria, ehk antud juhul keskmise haridustasemega inimeste, keskmistsissetulekut ($763.35$), *haridustaseKõrge* regressioonikordaja tähistab kõrge haridustasemega inimeste skoori erinevust referentskategooria keskmisest (vabaliikmest) ja *haridustaseMadal* madala haridustasemega inimeste skoori erinevust referentskategooria keskmisest (vabaliikmest).

Võrrandi kujul näeb tulem välja järgmine:
$$y_i=\beta_0+\beta_1 \times korge_i+\beta_2 \times madal_i$$

\begin{align}
&=
  \begin{cases}
    763.35+217.23 \times 1+(-22.20) \times 0 & \quad \text{kõrge haridustase}\\
    763.35+217.23 \times 0+(-22.20) \times 1 & \quad \text{madal haridustase}\\
    763.35+217.23 \times 0+(-22.20) \times 0 & \quad \text{keskmine haridustase}
  \end{cases}\\
&=
  \begin{cases}
    763.35+217.23+0  & \quad \text{kõrge haridustase}\\
    763.35+0-22.20  & \quad \text{madal haridustase}\\
    763.35+0+0  & \quad \text{keskmine haridustase}
  \end{cases}\\
&=
  \begin{cases}
    980.58  & \quad \text{kõrge haridustase}\\
    741.15  & \quad \text{madal haridustase}\\
    763.35  & \quad \text{keskmine haridustase}
  \end{cases}
\end{align}


Kui kategoriaalne sõltumatu tunnus on tekstiline (*character*), siis valib R referentskategooriaks tähestikuliselt esimese kategooria. Kui tunnus on faktortunnus (*factor*), siis valib R esimese faktortaseme. Faktortasemeid saame me aga muuta. Tihti tahame referentskategooria ise valida (näiteks kõige suurema grupi või grupi, mida on loogiline teistega võrrelda). Näiteks tahame haridustasemete puhul määrata referentskategooriaks põhihariduse. Selleks teeme tunnuse faktoriks ja määrame tasemete järjestuse nii, et madal haridustase oleks esimene:

```{r}
# vaatame kõigepealt mis kategooriad tunnuses on
unique(piaac$haridustase)
# Laeme forcats paketti, millega on mugav faktoritega toimetada
library(forcats)
# Kasutame funktsiooni fct_relevel()
# Meil on antud juhul vaja määrata ainult esimene tasand,
#  ülejäänud tulevad tähestiku järjekorras.
piaac <- piaac %>% 
  mutate(haridustase_f = fct_relevel(haridustase, "Madal"))

# Baas-R-is käiks faktori tegemine nii:
#piaac$haridustase_f <- factor(piaac$haridustase, 
#                              levels = c("Madal","Keskmine","Kõrge"))

# ja kui me nüüd regressiooni jooksutame, on referentsiks madal tase
summary(lm(sissetulek ~ haridustase_f, data = piaac))
```

Kui meil juba on faktortunnus, aga tahame selle tasemete järjekorda muuta, saame jälle kasutada käsku `fct_relevel()`. Muudame haridustaseme faktortunnuses kõrgema hariduse esimeseks tasemeks:

```{r}
piaac$haridustase_f <- fct_relevel(piaac$haridustase_f, "Kõrge")

# Baas-R-is käiks see nii:
#piaac$haridustase_f <- relevel(piaac$haridustase_f, ref = "Kõrge")

summary(lm(numeracy ~ haridustase_f, data = piaac))
```


::: {.teie-kord}
Ülesanne!  

* Piaaci andmestikus on tunnus *meeldib_oppida*. Tehke see faktortunnuseks nii, et esimene kategooria oleks "Mõningal määral" (kategooriate nimed saate teada näiteks funnktsiooniga `unique(piaac$meeldib_oppida)`)
* Tehke regressioonimudel, kus hindate õppimishimu mõju sissetulekule 
:::


## Mitmene regressioon

Siiani oleme käsitlenud lineaarset regressiooni, kus sõltumatuid tunnuseid oli üks. Aga on võimalik lülitada ühte mudelisse ka mitu sõltumatut tunnust. Miks see hea peaks olema?  

Valdavalt üritame välja selgitada (või tegelikult mingi teooria põhjal testida) mingi tunnuse kausaalset mõju teisele tunnusele (sõltumatu tunnuse mõju sõltuvale tunnusele). Kausaalsusel on aga teatud eeldused:  

1. Tunnuste vaheline seos (seose olemasolu ei tähenda muidugi kohe põhjalikkust)  
2. Ajaline järgnevus (vastupidi ei saaks ju kuidagi olla)  
3. Alternatiivse seletuse/põhjuse kõrvaldamine (sõltuv tunnus võib olla sõltumatu tunnuse poolt mõjutatud läbi mõne muu tunnuse, st kaudselt)  

Mitmene regressioon võimaldabki meil testida sõltumatute tunnuste otsest mõju sõltuvale tunnusele, kontrollides samal ajal teiste mudelisse lülitatud sõltumatute tunnuste mõjude suhtes (hoides teisi tunnuseid konstantsetena). Regressioonivõrrand mitme sõltumatu tunnuse puhul on sarnane ühese regressiooni võrrandiga, välja arvatud siis sõltumatute tunnuste arv. Mudel $y$ prognoosimiseks $p$ sõltumatute tunnuste kaudu on väljendatav järgmiselt:    

\begin{equation}  
y_{i}=\beta_{0}+\beta_{1}x_{i,1}+\beta_{2}x_{i,2}+\ldots+\beta_{p}x_{i,p}+\epsilon_{i}
\end{equation}

Kus:  

$\beta_0$ on vabaliige (ehk $y$ väärtus kui kõik sõltumatud tunnused on $0$'id)

$\beta_1$ regressioonikoeffitsient esimesele sõltumatule tunnusele $x_1$  

$\beta_2$ regressioonikoeffitsient teisele sõltumatule tunnusele $x_2$  

$\beta_{p}$ regressioonikoeffitsient tunnusele $x_{p}$  

$\epsilon$ on mudeli jääk igale vaatlusele

$\beta$ coefitsinedid on leitud nii, et nendega kaalutud tunnuste väärtused minimeerivad $\epsilon$'i ehk mudeli viga (kogu mudeli mõistes minimeerivad ruuthälvete summat). $\beta$ väärtus on tõlgendatav kui muutus $y$ väärtuses, kui vastava sõltumatu tunnuse väärtus muutub ühe ühiku võrra, hoides samal ajal teisi sõltumatuid tunnuseid konstantsetena. See tähendab, et koefitsientides on teiste tunnuste mõju arvesse võetud ja meie tulemused peegeldavad nn "puhast" mõju. 

Mudeli defineerimisel R-is saame sõltumatuid tunnuseid lisada `+` märgi abil:

```{r}
mudel4 <- lm(sissetulek ~ numeracy + sugu, data = piaac)
summary(mudel4)
```

Mitmese regressiooni tõlgendus on analoogne lihtsa regressiooni tõlgendusega. Võrrandi kujul on see väljendatav järgmiselt:

$$\hat{y}_{sissetulek}=\beta_0+\beta_1 \times numeracy + \beta_2 \times naine$$

\begin{align}
&=
  \begin{cases}
    \beta_0+\beta_1 \times numeracy + \beta_2 \times 1 =  & \quad \text{naine}\\
    \beta_0+\beta_1 \times numeracy + \beta_2 \times 0 =  & \quad \text{mees}
  \end{cases}\\
&=
  \begin{cases}
    (\beta_0+\beta_2)+\beta_1 \times numeracy  & \quad \text{naine}\\
    \beta_0+\beta_1 \times numeracy & \quad \text{mees}
  \end{cases}\\
\end{align}



Vabaliige näitab kategoriaalse tunnuse referentskategooria (antud juhul mees) keskmist sõltuva tunnuse väärtust. Aga kuna nüüd on meil mudelis ka sõltumatu pidevtunnus, siis on see referentskategooria keskmine juhul, kui sõltumatu pidevtunnus on $0$. Ehk siis meie näite puhul tähistab vabaliige ($140.8$) meeste sissetulekut juhul kui nende matemaatilise kirjaoskuse skoor on $0$. *suguNaine* regressioonikordaja näitab naiste sissetuleku erinevust meestest. See võtab arvesse ka matemaatilise kirjaoskuse skoori. Ehk siis kõikide matemaatilise kirjaoskuse väärtuste puhul on on naiste sissetulek $365$ eurot meestest madalam (st soo mõju on kontrollitud matemaatilise kirjaoskuse suhtes). *numeracy* regressioonikordaja näitab jällegi sissetuleku muutust ($3.35$) kui matemaatiline kirjaoskus muutub ühe ühiku võrra. Kuna ka sugu on mudelis arvesse võetud, kehtib see muutus võrdselt nii naistele kui meestele (mõju on kontrollitud soo suhtes).  

Vaatame, milliseks kujunevad mudeli järgi meeste ja naiste keskmised sissetulekud, kui nende *numeracy* skoor on 300. 

$$\hat{y}_{sissetulek}=140.8+3.35 \times numeracy + (-365) \times naine$$

\begin{align}
&=
  \begin{cases}
    140.8+3.35 \times 300 + (-365) \times 1  & \quad \text{naine}\\
    140.8+3.35 \times 300 + (-365) \times 0  & \quad \text{mees}
  \end{cases}\\
&=
  \begin{cases}
    (140.8-365)+3.35 \times 300  & \quad \text{naine}\\
    140.8+3.35 \times 300 & \quad \text{mees}
  \end{cases}\\
&=
  \begin{cases}
    -224.2+1005  & \quad \text{naine}\\
    140.8+1005 & \quad \text{mees}
  \end{cases}\\
&=
  \begin{cases}
    780.8  & \quad \text{naine}\\
    1145.8 & \quad \text{mees}
  \end{cases}
\end{align}


Mõnevõrra lihtsam on seda tulemust interpreteerida graafiliselt: 

```{r reg-plot-7,  echo=T, warning=F, message=FALSE}
piaac %>% 
  ggplot(aes(x = numeracy, y = sissetulek, color = sugu))+
  geom_point(alpha = 0.1, size = 0.3)+
  geom_abline(intercept = 140.8, slope = 3.35, color = "#972D15")+
  geom_abline(intercept = 140.8-365, slope = 3.35, color = "#02401B")+
  scale_colour_manual(values = c("Mees" = "#972D15", "Naine" = "#02401B"))+
  theme_minimal()+
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1)))
```

Lihtsam võimalus seoseid graafiliselt esitada on kasutada paketist `interactions` funktsiooni `interaction_plot()`. See on küll mõeldud eelkõige koosmõjude plottimiseks, kuid toimib ka tavalisete seoste kujutamisel.

```{r}
library(interactions)
interact_plot(mudel4, pred = numeracy, modx = sugu, colors = c("#972D15", "#02401B"))
```

### Kaks pidevat sõltumatut muutujat

Vaatame ka olukorda, kus meil on kaks pidevat sõltumatut tunnust - matemaatiline kirjaoskus ja vanus:

```{r}
mudel5 <- lm(sissetulek~numeracy+vanus, data = piaac)
summary(mudel5)
```

Tõlgendame seda järmiselt: 

1. Kui matemaatiline kirjaoskus tõuseb ühe punkti võrra, siis sissetulek tõuseb $3.48$ euro võrra, hoides vanust konstantsena (st see seos kehtib kõikide vanuste jaoks).  
2. Kui vanus tõuseb ühe aasta võrra, siis sissetulek langeb $3.2$ euro võrra, hoides funktsionaalset lugemisoskust konstantsena (st see seos kehtib kogu funktsionaalse lugemisoskuse skaala ulatuses).  
3. Juhul kui nii vanus oleks $0$ aastat ja matemaatiline kirjaoskus oleks $0$ punkti, oleks sissetulek $25.3$ eurot (kuna selline olukord on suhteliselt võimatu, siis me sellistel puhkudel vabaliiget ei interpreteeri).  

Et taolisest mudelist paremini aru saada võime kasutada 3D punktdiagrammi

```{r message=F}
#library(car)
#scatter3d(piaac$numeracy,piaac$sissetulek, piaac$vanus)
```



::: {.teie-kord}
Ülesanne!  

* Looge regressioonimudel, millega hindate *numeracy*, *vanus*, *sugu* ja *haridustase* mõju sissetulekule.
* Milliste tunnuste mõju sissetulekule on statistiliselt oluline?
* Esitage vanuse ja soo mõju sissetulekule graafiliselt.
:::



## Koosmõjud
Eelnevas näites vaatasime sissetuleku sõltuvust matemaatilise kirjaoskuse tasemest soo lõikes, ja nägime, et kui lisame mudelisse soo tunnuse, siis saame klasside kohta eraldi regressioonijooned. Kuid need regressioonijooned olid paralleelsed, mis tähendab et nii meeste kui naiste hulgas oli funktsionaalse lugemisoskuse ja matemaatilise kirjaoskuse suhe mudeli järgi sama. Kuid kas see on alati väga realistlik eeldus? Võib ju vabalt olla, et see seos erineb soo lõikes.  

Kui me arvame, et see võib nii olla, st sõltumatu tunnuse mõju sõltuvale tunnusele sõltub omakorda mingist muust tunnusest, saame mudelisse lisada nende kahe tunnuse koosmõju (interaktsiooni). Selleks peame moodustame uue tunnuse, mis tuleneb nende tunnuste, mille suhtes me koosmõju hinnata tahame, korrutisest. Kui me nüüd selle uue tunnuse mudelisse kaasame, siis hindame sellele ka regressioonikoefitsiendi. Regressioonivõrrand pidevtunnuse ja kategoriaalse tunnuse koosmõjuga näeks välja nii:


$$\hat{y}_{sissetulek}=\beta_0+\beta_1 \times numeracy + \beta_2 \times naine + \beta_3 \times naine \times numeracy $$

\begin{align}
&=
  \begin{cases}
    \beta_0+\beta_1 \times numeracy + \beta_2 \times 1 + \beta_3 \times 1 \times numeracy  & \quad \text{naised}\\
    \beta_0+\beta_1 \times numeracy + \beta_2 \times 0 + \beta_3 \times 0 \times numeracy & \quad \text{mehed}
  \end{cases}\\
&=
  \begin{cases}
    (\beta_0+\beta_2)+(\beta_1+\beta_3) \times numeracy  & \quad \text{naised}\\
    \beta_0+\beta_1 \times numeracy & \quad \text{mehed}
  \end{cases}
\end{align}

Mis siin nüüd siis toimub? Meeste keskmine sissetulek on, nagu varasemaltki, defineeritud vabaliikme ja $\beta_1$ regressioonikoefitsiendiga (ülejäänud kaks koefitsienti lähevad meeste jaoks $0$-ks, kuna *naine* tunnus on nende jaoks $0$). Naistel on aga lisaks veel kaks koefitsienti. $\beta_2$, mis nagu varasemaltki kirjeldab naiste vabaliikme erinevust meeste vabaliikmest, ning siis veel $\beta_3$, mis kirjeldab naiste regressioonisirge erinevust meeste regressioonisirgest. Koosmõjudega mudelis on naiste *numeracy* koefitsient $\beta_1+\beta_3$ (sest $\beta_1 \times numeracy + \beta_3 \times numeracy = (\beta_1+\beta_3) \times numeracy$).

R-is saame taolise mudeli defineerida järgmiselt:

```{r}
mudel8 <- lm(sissetulek ~ numeracy * sugu, data = piaac)
summary(mudel8)

# Sama tulemuse saaksime, kui kirjutaksime:
#lm(numeracy ~ literacy + sugu + literacy:sugu, data = piaac)

```

Koosmõjudega mudeli vabaliikmed ja regressioonikoefitsiendid kujunevad järgmiselt:

$$\hat{y}_{sissetulek}=\beta_0+\beta_1 \times numeracy + \beta_2 \times naine + \beta_3 \times naine \times numeracy$$

\begin{align}
&=
  \begin{cases}
    28.5+3.8 \times numeracy + (-157) \times 1 + (-0.7) \times 1 \times numeracy & \quad \text{naised}\\
    28.5+3.8 \times numeracy + (-157) \times 0 + (-0.7) \times 0 \times numeracy & \quad \text{mehed}
  \end{cases}\\
&=
  \begin{cases}
    (28.5-157)+(3.8-0.7) \times numeracy  & \quad \text{naised}\\
    28.5+3.8 \times numeracy & \quad \text{mehed}
  \end{cases}\\
&=
  \begin{cases}
    -128.5+3.1 \times numeracy  & \quad \text{naised}\\
    28.5+3.8 \times numeracy & \quad \text{mehed}
  \end{cases}
\end{align}

Seega selles mudelis erinevad kategoriaalse tunnuse lõikes nii vabaliikme väärtused kui ka regressioonisirge tõusud. Kui me nüüd selle mudeli tulemused graafikule paneme, siis näeme, et regressioonisirged ei ole enam paralleelsed. Mida suurem on matemaatilise kirjaoskuse tase, seda suurem on erinevus meeste ja naiste sissetulekutes.

```{r reg-plot-8,  echo=T, warning=F, message=FALSE}
interact_plot(mudel8, pred = numeracy, modx = sugu,  colors =  c("#972D15", "#02401B"))
```


### Koosmõjud kategoriaalsete tunnuste puhul

Enne oli juttu, et kahe kategoriaalse sõltumatu tunnusega mudel ilma koosmõjudeta pole väga mõistlik. Vaatame nüüd kuidas see koosmõjudega välja näeks:

```{r}
mudel9 <- lm(sissetulek ~ sugu * haridustase, data = piaac)
summary(mudel9)
```

Sellisest mudelist saame välja lugeda kõikide gruppide ristlõigete (kõrge haridustasemega naised, kõrge haridustasemega mehed jne) keskmised. Arvutame näiteks välja kõrge haridustasemega (*koh*) naiste ja madala haridustasemega (*mh*) meeste keskmised matemaatilise lugemisoskuse skoorid:

$$\hat{y}_{sissetulek}=\beta_0+\beta_1 \times naine + \beta_2 \times koh + \beta_3 \times mh + \beta_4 \times naine \times koh + \beta_5 \times naine \times mh$$

\begin{align}
&=
  \begin{cases}
    1004.5+(-458.8) \times 1 + 252.60 \times 1 + (-73.55) \times 0 + 50.69 \times 1 + 10.76 \times 0 & \quad \text{kõrge haridustasemega naised}\\
    1004.5+(-458.8) \times 0 + 252.60 \times 0 + (-73.55) \times 1 + 50.69 \times 0 + 10.76 \times 0 & \quad \text{madala haridustasemega mehed}
  \end{cases}\\
&=
  \begin{cases}
    1004.5+(-458.8) + 252.60 + 50.69 & \quad \text{kõrge haridustasemega naised}\\
    1004.5 + (-73.55) & \quad \text{madala haridustasemega mehed}
  \end{cases}\\
&=
  \begin{cases}
    849 & \quad \text{kõrge haridustasemega naised}\\
    931 & \quad \text{madala haridustasemega mehed}
  \end{cases}
\end{align}


Vaatame seda mudelit ka graafiliselt (kasutame paketi `interactions` funktsiooni `cat_plot()`):

```{r}
cat_plot(mudel9, pred = haridustase, modx = sugu, colors =  c("#972D15", "#02401B"))
```



::: {.teie-kord}
Ülesanne!  

* Looge koosmõjuga regressioonimudel, millega hindate soo ja laste olemasolu mõju sissetulekule.
* Esitage koosmõjud graafikul (`cat_plot()` abiga) 
:::


## Mudelite võrdlemine
Milline on hea mudel? See peaks muidugi seletama võimalikult palju sõltuva tunnuse varieeruvusest. Samas peaks see olema ka võimalikult ökonoomne, st see peaks sisaldama ainult tunnuseid, mis mudelit oluliselt paremaks teevad. Siin on rõhk sõnal "oluliselt". Iga lisanduv tunnus teeb mudeli mingil määral paremaks, kuid see paranemine võib olla mikroskoopiline. Kuidas siis hinnata, kas mudel $n+1$ tunnusega on oluliselt parem kui $n$ tunnusega mudel?   

Me saame vaadata lisanduva tunnuse standardviga, *t*-väärtust ja sellega seonduvat *p*-väärtust. Kuid nagu enne jutuks oli, testib see ainult konkreetse koefitsiendi erinevust nullist. Meid aga huvitab kogu mudeli kvaliteet. Võimalus on ka võrrelda mudelite $R^2$ väärtusi, kuid need on pigem kirjeldavad, ega anna meile indikatsiooni sellest kas üks väärtus on oluliselt parem kui teine. 

Erinevate mudelite statistiliselt olulist erinevust saame testida hii-ruut testiga kasutades `anova()` funktsiooni. Seda saab teha ainult siis kui mudelid on omavehl seotud (*nested*), st keerukam (rohkemate tunnustega) mudel peab sisdaldama kõiki lihtsama mudeli tunnuseid.

```{r}
mudel_test1 <- lm(numeracy ~ literacy, data = piaac)
mudel_test2 <- lm(numeracy ~ literacy + sugu, data = piaac)
anova(mudel_test1, mudel_test2, test = "Chisq")
```

Tõlgendame jällegi testi *p*-väärtust. Kui see on väiksem kui $0.05$ (usaldusnivool $95\%$), siis võime järeldada, et mudelid on oluliselt erinevad, mis tähendab omakorda, et lisatud tunnus tõstis mudeli selgitusvõimet olulisel määral.


## Regressioonimudeli eeldused  

Nagu iga meetodi puhul, on ka lineaarsel regressioonanalüüsil rida eeldusi, mis peavad olema täidetud, et analüüsist korrektseid järeldusi oleks võimalik teha.

1. Esimene ja vahest ka kõige olulisem eeldus on **lineaarne suhe sõltuva ja sõltumatu(te) tunnuse vahel**. Kõrvaloleval joonisel on esitatud neli andmestikku, mille regressioonisirged on identsed ($y=3+0.5x$). Tegelikult on identsed ka kõik muud andmete statistilised omadused ($x$'i keskmine, $y$'i keskmine, $x$'i dispersioon, $y$'i dispersioon ja ka korrelatsioon). Ometi on visuaalselt näha, et kõik andmestikud on väga erinevad. Seega peaks regressioonanalüüsi (või tegelikult ükskõik mis analüüsi) puhul olema alati esimene samm neid graafiliselt uurida. Kui tunnuste vaheline seos ei ole lineaarne, piisab mõnel juhul tunnuste  mittelineaarsest transformeerimisest (see peaks olema ka muidugi teoreetiliselt põhjendatud). Kui seos on eksponentsiaalne, siis võib kaaluda *log*-transformatsiooni. Kui seos on paraboolne, siis võib kaaluda ruutu tõstetud tunnuse lisamist ehk polünoomset regressiooni ($y = \beta_0+\beta_1x+\beta_2x^2$). Taoliste transformatsioonide juures peab meeles pidama, et koos nendega muutub ka mudeli tõlgendus.  

```{r anscombe, fig.cap = "Anscombe kvartett", fig.height=4.5,  echo=F, warning=F, fig.show='hold'}
p1 <- ggplot(anscombe) + geom_point(aes(x1, y1), color = cols[1], size = 1) + theme_bw() + scale_x_continuous(breaks = seq(0, 20, 2)) + scale_y_continuous(breaks = seq(0, 12, 2)) + geom_abline(intercept = 3, slope = 0.5) + expand_limits(x = 0, y = 0)
p2 <- ggplot(anscombe) + geom_point(aes(x2, y2), color = cols[1], size = 1) + theme_bw() + scale_x_continuous(breaks = seq(0, 20, 2)) + scale_y_continuous(breaks = seq(0, 12, 2)) + geom_abline(intercept = 3, slope = 0.5) + expand_limits(x = 0, y = 0)
p3 <- ggplot(anscombe) + geom_point(aes(x3, y3), color = cols[1], size = 1) + theme_bw() + scale_x_continuous(breaks = seq(0, 20, 2)) + scale_y_continuous(breaks = seq(0, 12, 2)) + geom_abline(intercept = 3, slope = 0.5) + expand_limits(x = 0, y = 0)
p4 <- ggplot(anscombe) + geom_point(aes(x4, y4), color = cols[1], size = 1) + theme_bw() + scale_x_continuous(breaks = seq(0, 20, 2)) + scale_y_continuous(breaks = seq(0, 12, 2)) + geom_abline(intercept = 3, slope = 0.5) + expand_limits(x = 0, y = 0)

grid.arrange(p1, p2, p3, p4)

```

2. Lineaarse regressiooni puhul peaks tähelepanelik olema ka **erindite** (*outliers*)suhtes, st vaatluste suhtes, mis erinevad teistest väga olulisel määral (nagu ka kõrvalolevalt jooniselt näha). Mõnede andmete puhul on erindid paratamatud (näiteks sissetuleku puhul, kus suurem osa inimesi on koondunud keskmise sissetuleku ümber, kuid mõned üksikud teenivad sellest oluliselt enam). Sellisel juhul tasuks kaaluda jällegi tunnuse transformeerimist (sissetuleku puhul näiteks log-skaalale). Kui tegemist on mõne üksiku erindiga, võiks ju selle aluseks oleva vaatluse ka lihtsalt analüüsist välja jätta. Siin tuleks aga olla väga ettevaatlik. Andmete või sellest saadava informatsiooni tahtlik vähendamine (näiteks pidevtunnuste kategoriseerimine) ei ole üldiselt kunagi hea mõte. Seda enam ei ole hea mõte andmete vähendamine eesmärgiga mudelit paremaks teha. Kui aga erindite tekkimine on mingil moel teoreetiliselt seletatav või tulenenud näiteks veast andmekorjel, siis võib seda loomulikult teha.  

3. **Jääkide dispersiooni homogeensus** (*homoscedasticity*). Jäägid peaksid hinnatud väärtuste lõikes olema homogeense ja konstantse variatiivsusega, st ühtlaselt jaotunud kõikide $\hat{y}$ väärtuste ümber. Selle eelduse rikkumine mõjutab eelkõige standardvigu (need ei kehti enam kõikidele $\hat{y}$ väärtustele ühtlaselt) ja seeläbi loomulikult ka usaldusintervalle ning *p*-väärtusi. Lahenduseks võivad olla nn robustsed standardvead (*robust standard errors*), mis võtavad varieeruvuse erinevust arvesse.

```{r, message=F}

## Robust standard errors

# Defineerime regressioonimudeli 
mudel6 <- lm(numeracy ~ literacy * sugu, 
             data = piaac)

# summary() funktsiooniga saame kätte tavalised standardvead
summary(mudel6)

# Robustsete standardvigade arvutamiseks kasutame sandwitch paketti
#  ja nende kuvamiseks lmtest paketti
library(sandwich)
library(lmtest)

# Robustsete standardvigade jaoks tuleb meil arvutada uus 
#  'robustne' koefitsientide variatsiooni-kovariatsiooni maatriks ehk nn 
#  Heteroscedasticity-Consistent Covariance Matrix. sandwitch paketis
#  on selleks funktsioon vcovHC().

# Variatsiooni-kovariatsiooni maatriksi diagonaalis on koefitsientide 
#  dispersioonid (variance). Ruutjuur dispersioonist annab koefitsiendi 
#  standardhälbe, mis on ongi pareameetri standardviga
# Seega saame robustsed standardvead kätte nii:
vcovHC(mudel6) %>% 
  diag() %>% 
  sqrt()

# Et neid koos koefitsientide ja vastavate testidega kuvada, võime kasutada
#  lmtest paketi funktsiooni coeftest()
coeftest(mudel6, vcov. = vcovHC(mudel6))

# Usalduspiirid robustsete standardvigade alusel saame kätte coefci() 
#  funktsiooniga
coefci(mudel6, vcov. = vcovHC(mudel6))

```


4. **Jääkide normaaljaotus**. Regressiooni jäägid peaksid olema normaaljaotusega $e_i \sim N(0, \sigma^2)$, seega enamus jääke peaks jääma nulli ümber ning mida suuremad jäägid, seda vähem neid olema peaks. See eeldus on eelkõige oluline regressioonikoefitsientide *t*-testi jaoks.

1. **Jääkide sõltumatus**. Ühe vaatluse jäägid ei tohiks olla korreleeritud teise vaatluse jääkidega. Selline olukord võib tekkida näiteks siis kui meil mudelist välja jäänud mingi oluline tunnus (ühe tunnuse regressiooni puhul on see muidugi vaid hüpoteetiline olukord), näiteks hindame õpilaste testiskoore lähtuvalt nende õppimisele kulunud ajast, kuid ei arvesta, et õpilased tulevad erinevatest koolidest, kus võib olla erinev õppetase. Seega õpilaste tulemused ei ole enam sõltumatud, vaid sõltuvad koolist. Regressioonikoefitsientide standardvigade arvutamisel lähtutakse eeldusest, et jäägid on sõltumatud. Kui jäägid on korreleeritud, siis võib juhtuda, et me alahindame standardvigade suurust ehk siis oleme oma tulemustes ülemäära kindlad (usaldusintervallid ning *p*-väärtused tulevad liialt väikesed) ning võime näha seoseid seal kus neid tegelikult ei ole. Lahenduseks võiks olla puuduolevate tunnuste lisamine mudelisse (konkrteetse näite puhul kooli tunnus) või klasterdatud standardvead (*clustered standard errors* või ka *cluster-robust standard errors*).

```{r, message=F}

## Clustered standard errors

# Eeldame, et valim on klasterdatud haridusvaldkonna alusel
# Defineerime regressioonimudeli 
#  (jätame välja kõik vaatlused, kus haridusvaldkond on NA)
mudel6 <- lm(numeracy ~ literacy * sugu, 
             data = piaac[!is.na(piaac$hvaldkond),])


# Klasterdatud standardvigade arvutamiseks kasutame jälle sandwitch paketti ja
# selle funktsiooni vcovCL()
library(sandwich)
library(lmtest)

# Robustsete standardvigade jaoks tuleb meil arvutada uus 
#  'klasterdatud' koefitsientide variatsiooni-kovariatsiooni maatriks ehk nn 
#  Clustered Covariance Matrix. sandwitch paketis
#  on selleks funktsioon vcovCL(). Peame selles lisaks mudeliobjektile
#  määrama ka klastritunnuse

vcovCL(mudel6, cluster = ~hvaldkond) %>% 
  diag() %>% 
  sqrt()

# Et neid koos koefitsientide ja vastavate testidega kuvada, võime kasutada
#  jällegi lmtest paketi funktsiooni coeftest()
coeftest(mudel6, vcov. = vcovCL(mudel6, cluster = ~hvaldkond))


```


1. Kui kaks sõltumatut tunnust on teineteisega väga tugevalt seotud põhjusteab see nn **kollineaarsust**. See võib tekitada probleeme mudeli hindamisel ning ka tõlgendusel. Lisaks kipuvad standardvead liialt suureks minema, mis tähendab seda, et kaotame oma tulemuste täpsuses ja võime mitte näha seoseid seal, kus need tegelikult olemas on. Seega võiks tähele panna, et korrelatsioon sõltumatute muutujate vahel peaks alati olema väiksem kui korrelatsioon sõltuva ja sõltumatu muutuja vahel.


## Kuidas eelduste täidetust hinnata?

Eelduste hindamiseks on loomulikult mitmeid teste, kuid kõige lihtsam on seda mudeli diagnostiliste joonistega.

```{r}
mod <- lm(formula = sissetulek ~ numeracy + vanus + sugu + haridustase, 
    data = piaac)
```



```{r, fig.height=4}
plot(mod, 1)
```

Kontrollime mittelineaarse seose olemasolu. Punktid peaksid olema ühtlaselt ümber keskmise joone jaotunud. Ei tohiks olla mingit ilmset mustrit.

```{r, fig.height=4}
plot(mod, 2)
```

Kas jäägid on normaalselt jaotunud? Punktid peaksid ühtima diagonaalse joonega.

```{r, fig.height=4}
plot(mod, 3)
```

Kas jääkide dispersioon on homogeenne? Punane joon peaks olema horisontaalne ja punktid peaksid olema ühtlaselt jaotunud ega tohiks mingit mustrit moodustada.

```{r, fig.height=4}
plot(mod, 5)
```

Kas mudelis on mudelit oluliselt mõjutavaid erindeid? Kui on, siis peaksid need olema paremal all või paremal üleval nurgas ning kaugemal kui punktiirjoon (antud juhul neid ei ole ja seega ei ole ka punktiirjoont näha).








